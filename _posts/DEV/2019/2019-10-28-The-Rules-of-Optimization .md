---
layout: post
title: 'The Rules of Optimization'
categories: DEV
date: 2019-10-28
lastmod : 2019-10-28 09:00:00
sitemap :
changefreq : daily
priority : 1.0
---

<br>

<center><span style="color:red">Kat Busch가 작성한 원문을 토대로 쓴 글임을 밝혀둡니다.</span></center>

<br>

근래에 들어, 컴퓨터 성능이 비약적으로 발전하면서, 성능 개선이란 몇몇 개발자들만 늘 생각하는 그 무엇인가로 남아버렸습니다. 그래도 우리 모두는 개발자라면 성능 개선이라는 목표는 언젠가는 고려하는 상황을 맞이하게 됩니다.  

사실 정작 필요하지 않은 경우인데도 우리는 늘 성능 개선을 고민합니다. 이러한 고민이 우리 삶 뿐만 아니라 코드와 연관된 다른 개발자들의 삶을 복잡하게 만드는 존재임에도요. 그래서 내린 성능 개선에 대한 저의 첫 번째 법칙:



**하지 마라!**



놀래셨나요? 성능 개선에 대한 저만의 법칙에 대해서 자세히 설명드리겠습니다. 그리고 정말 진정으로 성능개선이 필요한 시점에 드릴 수 있는 조언도 몇 가지 첨언하겠습니다. 



#### Part 1. The Bottleneck



제 경험담을 먼저 들려드리죠.  대학생 시절 여름학기 연구과제로 개발중인 유전자 분석 프로그램이 너무 느렸습니다. 지도 교수는 해당 프로그램에서 Graph Coloring 알고리즘이 시간을 많이 잡아먹는다고 말했죠. 그래서 저는  해당 부분에 대한 성능 개선을 시도하기로 했습니다. 



결론적으로 저는 해당 부분에 대한 시간을 줄이는데 성공했습니다!! 기존 대비 70%의 개선이었죠! 매우 신났죠. 

몇 주간의 추가적인 성능 개선후에 드디어 전체 프로그램을 돌렸습니다.. 

그런데.. 이게 뭐죠??

정작 전체 프로그램을 돌려보니 성능 개선은 15% 밖에 이루어지지 않았습니다.. 어떻게 된거죠? 분명 저는 70% 성능 개선을 이뤘다고 자부했는데??  찬찬히 무엇이 문제인지 살펴보았습니다.. 아차!... 제가 수정한 그 프로그램은 결과를 파일에 기록하는 거였고. 수많은 파일들을 한꺼번에 기록하기 위해 제 프로그램은 수많은 프로세스를 생성했더랬죠.. 그러다보니 운영체제에서는 그렇게 생성된 프로세스들을 스케쥴링하다보니, 하드 디스크는 각 파일을 기록하기 위해서 엄청난 수의 액세스 작업을 반복했더랬습니다. 참고로 하드 디스크 탐색에는 꽤 많은 시간이 소요됩니다. 

근본적인 문제점을 알고, lock 을 사용해 한 프로세스만 파일 쓰기가 가능하도록 몇 줄의 코드를 추가하였고, 단지 그 몇 줄의 추가로 기존 대비 60% 성능 개선 효과를 얻었습니다. **단 몇 줄의 추가로...** 이건 제가 Graph Coloring 알고리즘 개선을 위해 들였던 몇 주간의 성과로도 이루지 못했던 것이죠.. 제 지도 교수가 저에게 Graph Coloring을 C++로 작성해서 성능 개선을 볼 수 있을것이라고 조언했던건, 그가 실제로 거기에 많은 시간을 할애 했었기 때문이라고 짐작합니다. 그리고 결과를 파일로 기록하는 부분에 대해서는 단 몇 분밖에 노력을 들이지 않았을 것으로 생각됩니다. 



저는 오랜 기간 동안 성능 개선과 연관된 업무를 하면서, 수많은 개발자들이 성능 개선에 엄청난 시간을 투자하면서도 결국 아무것도 얻지 못하는 광경들을 수없이 목격했습니다. 실패하는 경우의 공통점은 **정확히 어디가 Bottleneck**인지 모르는 상태에서 작업을 하는 것입니다. 



**"정확히 Bottleneck이 어딘지 모르는 상황에서, 시도하는 성능 개선은 반드시 실패한다"**



보통은 자신이 건드리는 부분이 Bottleneck라고 생각합니다. 그러나 그건 숲은 보지 못하고 나무를 보는 것과 같죠. 전체적인 그림을 보는 것이 아니라 아주 단편을 보는 것일 수도 있습니다. 

<br>

우습게도, 이러한 실수는 아주 전문적인 경험 많은 개발자들도 하는 실수죠. 우리는 너무 우리가 갇힌 세계에 빠져, 바깥 세상에 대해서 잊어버리는 경우도 있습니다. 경험담을 들려드리죠. 한번은, 아주 숙련된 백엔드 전문가 개발 그룹에서 Python 대신 Go를 사용하여 복잡한 웹 엔드포인트를 재작성하는 것을 목격한 적이 있습니다. 그런데.. 결국 시간이 흘러 보니.. 정작 느린 웹페이지 로딩의 원인이 자신들이 담당하는 백엔드가 아닌, 앱의 브라우저 쪽 문제였던 것이죠. 한마디로, 그들의 성능 개선 작업은 말 그래도 헛다리 짚은거였죠. 

<br>

자.. 위에서 소개해드린 제가 목격한 경험담들.. 막 코딩에 입문한 초보자들이 하는 실수인것 같죠? 아닙니다. 자신의 시스템을 아주 잘 아는 사람도, 사실은 그 시스템을 벗어난 다른 연관 부분을 보지 못한 것이죠. 즉 나무만 보았지 숲을 보지 못하는 실수는 어떤 한 분야의 시스템 전문가도 할 수 있다는 것이죠. 



**항상 스스로에게 질문하세요! 어떤 성능 요소가 최종 사용자에게 영향을 주는 부분인건지?**

**그리고 당신이 작성한 코드는 그 성능 요소에 어떤 영향을 미치는지?**



#### Part 2. Complexity

정확히 Bottleneck이 어딘지 모르고 덤비는 성능개선은 당신의 코드에 해를 끼치는 행위입니다. 

성능 개선 작업은 사실 코드의 복잡도를 증가시키는게 일반적인 사실입니다. 

그렇기에, 불필요한 성능 개선은 괜시리 코드를 더 복잡하고 이해하기 어렵게 만들고 

심지어 의도하지 않은 버그도 만들어내죠. 