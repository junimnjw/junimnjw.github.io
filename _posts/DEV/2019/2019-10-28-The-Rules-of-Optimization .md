---
layout: post
title: 'The Rules of Optimization'
categories: DEV
date: 2019-10-28
lastmod : 2019-10-28 09:00:00
sitemap :
changefreq : daily
priority : 1.0
---

<br>

<center><span style="color:red">Kat Busch가 작성한 원문을 토대로 쓴 글임을 밝혀둡니다.</span></center>
<br>

 컴퓨터 성능이 비약적으로 발전하면서, 

성능 개선이란 단어에 대한 인기는 사실 이전만 못합니다. 

그래도 개발자라면 성능 개선은 피할 수 없는 것이죠. 

특히 임베디드 시스템 개발자라면 더욱 그렇죠. 

그런데 사실 성능 개선이 정말 필요하지 않은 상황인데도, 

우리는 늘 성능 개선에 목을 메고 고민하죠. 



그래서 드리는 성능 개선에 대한 첫 번째 법칙

<center><span style="color:black;font-size:40px">하지마라!</span></center>
엥? 뭐라고? 그럼 왜 이 포스트를 쓰는거지?

자.. 법칙에 대한 이유를 자세히 설명드리겠습니다. 

그리고 정말 성능개선이 필요한 시점에 드릴 수 있는 조언도 몇 가지 첨언하겠습니다. 



#### Part 1. The Bottleneck

제 경험담을 들려드리죠.  대학 시절 여름 연구과제로 개발중이었던 유전자 분석 프로그램이 너무 느렸습니다. 

지도 교수는 해당 프로그램에서 Graph Coloring 알고리즘이 시간을 많이 잡아먹는것 같다라고 말해주었죠. 

그래서 저는 그 말만 믿고 해당 부분에 대한 성능 개선을 시도했습니다. 



결론적으로 저는 해당 부분에 대한 성능 개선에 성공했습니다!! 

기존 대비 70%의 개선이었죠! 몇 주간의 추가적인 성능 개선후에 전체 프로그램을 돌렸습니다.. 

그런데.. 이게 뭐죠??

전체 프로그램을 돌려보니 성능 개선은 15% 밖에 이루어지지 않았습니다.. 어떻게 된거죠? 

분명 저는 70% 성능 개선을 이뤘다고 자부했는데??  

무엇이 문제인지 살펴보았습니다... 그리고 깨달았습니다. 

아차!... 제가 수정한 그 프로그램은 수행 결과를 화일에 기록하는 거였고. 

수많은 파일들을 한꺼번에 기록하기 위해 제 프로그램은 수많은 프로세스를 생성했더랬죠.. 

그러다보니 하드 디스크는 각 파일을 기록하기 위해서 엄청난 수의 액세스 작업을 반복했더랬습니다. 

참고로 하드 디스크 탐색에는 꽤 많은 시간이 소요됩니다. 



근본적인 문제점을 그제서야 깨닫고, 

Lock 을 사용해 한 프로세스만 파일 쓰기가 가능하도록 몇 줄의 코드를 추가하였고, 

단지 몇 줄의 추가로 기존 대비 60% 성능 개선 효과를 얻었습니다. **단 몇 줄의 추가로...** 

이건 제가 Graph Coloring 알고리즘 개선을 위해 들였던 몇 주간의 성과로도 이루지 못했던 것이죠.. 

제 지도 교수가 저에게 Graph Coloring을 C++로 작성해서 성능 개선을 볼 수 있을것이라고 조언했던건, 

그가 거기에 많은 시간을 할애 했었기 때문이라고 생각합니다. 

정작 파일로 결과를 기록하는 부분에 대해서는 단 몇 분밖에 노력을 들이지 않았을 것으로 생각됩니다. 



저는 오랜 기간 동안 성능 개선과 연관된 업무를 하면서, 

수많은 개발자들이 성능 개선에 엄청난 시간을 투자하면서도, 

결국 아무것도 얻지 못하는 광경들을 수없이 목격했습니다. 

그리고 실패하는 경우의 공통점은 모두 **정확히 어디가 Bottleneck**인지 모르는 상태에서 작업을 하는 것입니다. 



<center><span style="color:black;font-size:40px">정확히 Bottleneck이 어딘지 모르는 상황에서, 성능개선 시도는 반드시 실패한다.</span></center>


보통은 자신이 건드리는 부분이 Bottleneck라고 생각합니다. 

그러나 숲은 못보고 나무를 보는 것과 같죠. 

전체적인 그림을 보는 것이 아니라 아주 단편을 보는 것일 수도 있습니다. 

<br>

우습게도, 이러한 실수는 경험 많은 개발자들도 하는 실수죠. 

우리는 우리가 만든 세계에 갇혀서, 바깥 세상에 대해서 잊어버리는 경우도 있습니다. 

또 제 경험담을 들려드리죠. 한번은, 아주 숙련된 백엔드 전문가 개발 그룹에서 Python 대신 

Go라는 언어를 사용하여, 성능 개선을 목적으로 복잡한 웹 엔드포인트를 재작성하는 것을 목격한 적이 있습니다. 

그런데.. 시간이 흘러 보니.. 정작 느린 웹페이지 로딩의 원인이 자신들이 담당하는 백엔드가 아닌, 

앱의 브라우저 쪽 문제였던 것이죠. 한마디로, 그들의 성능 개선 작업은 헛다리 짚은거였죠. 

<br>

자! 위에서 소개해드린 경험담들.. 막 코딩에 입문한 초보자들이 하는 실수인것 같죠? 

아닙니다. 자신의 시스템을 아주 잘 아는 사람도, 사실은 그 시스템을 벗어난 다른 연관 부분을 보지 못한 것이죠. 

즉 나무만 보았지 숲을 보지 못하는 실수는 어떤 한 분야의 시스템 전문가도 할 수 있다는 것이죠. 



<center><span style="color:black;font-size:40px">항상 스스로에게 질문하세요! 어떤 성능 요소가 최종 사용자에게 영향을 주는 부분인건지? 그리고 당신이 작성한 코드는 그 성능 요소에 어떤 영향을 미치는지?</span></center>


#### Part 2. Complexity

정확히 Bottleneck이 어딘지 모르고 덤비는 성능개선은 당신의 코드에 해를 끼치는 행위입니다. 

성능 개선 작업은 보통 코드의 복잡도를 증가시키는게 일반적 사실입니다. 

그래서 불 필요한 성능 개선 작업은 코드를 더 복잡하고 이해하기 어렵게 만들고, 

심지어 의도하지 않은 버그도 만들어내죠. 